
function doGet(e) {
  try {
    const params = e && e.parameter ? e.parameter : {};
    const callback = params.callback ? String(params.callback).trim() : '';

    // Step 1: Handle User Sync (JSONP support)
    if (params.userId && callback) {
      const res = syncUserProfileToCentralGlobalSettings(params.userId);
      return ContentService.createTextOutput(callback + '(' + JSON.stringify(res) + ');').setMimeType(ContentService.MimeType.JAVASCRIPT);
    }

    // Step 2: Serve Price Feed
    const requestedCode = params.stockCode ? String(params.stockCode).trim().toUpperCase() : null;
    const compact = params.compact === 'true';

    // buildPriceFeedArray_ returns { prices: [], dashboard: [] }
    const data = buildPriceFeedArray_(requestedCode, { compact });
    const json = JSON.stringify(data);

    if (callback) {
      return ContentService.createTextOutput(callback + '(' + json + ');').setMimeType(ContentService.MimeType.JAVASCRIPT);
    } else {
      return ContentService.createTextOutput(json).setMimeType(ContentService.MimeType.JSON);
    }

  } catch (err) {
    const errObj = JSON.stringify({ error: true, message: String(err && err.message || err) });
    return ContentService.createTextOutput(errObj).setMimeType(ContentService.MimeType.JSON);
  }
}

/**
 * Extracts and separates data from multiple sheets (Prices and Dashboard).
 * @param {string} singleCode - Optional ticker to filter for
 * @param {Object} options - { compact: boolean }
 * @returns {Object} { prices: [], dashboard: [] }
 */
function buildPriceFeedArray_(singleCode, options) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const prices = [];
  const dashboard = [];
  const compact = options && options.compact;

  const processSheet = (sheetName, targetArray) => {
    const sh = ss.getSheetByName(sheetName);
    if (!sh) return;
    const values = sh.getDataRange().getValues();
    if (values.length < 2) return;
    const headers = values[0];
    const map = headers.reduce((acc, h, i) => { if (h) acc[String(h).trim()] = i; return acc; }, {});

    function col(variants) { 
      for (let v of variants) { if (map[v] != null) return map[v]; } 
      return null; 
    }
    
    // Column Index Resolution
    const idxCode = col(['ASXCode', 'ASX Code', 'Code', 'Ticker', 'Symbol']);
    const idxCompany = col(['CompanyName', 'Company Name', 'Name', 'Description']);
    const idxLive = col(['LivePrice', 'Last', 'Price', 'LastPrice', 'Last Trade']);
    const idxPrev = col(['PrevClose', 'PrevDayClose', 'Close', 'Previous']);
    const idxHigh52 = col(['High52', '52W High', '52 High', 'H52']);
    const idxLow52 = col(['Low52', '52W Low', '52 Low', 'L52']);
    const idxSector = col(['Sector', 'Category']);
    const idxIndustry = col(['Industry']);
    const idxMktCap = col(['MarketCap', 'Market Cap']);
    const idxPE = col(['PE', 'PE Ratio']);

    // Fuzzy Match Pointers for API Recovery
    const findFuzzy = (patterns) => {
      const idx = headers.findIndex(h => {
        if (!h) return false;
        const clean = String(h).replace(/[^A-Z0-9]/gi, '').toUpperCase();
        return patterns.some(p => clean === p);
      });
      return idx !== -1 ? idx : null;
    };
    const apiPriceIdx = findFuzzy(['APIPRICE', 'PIPRICE']);
    const apiPrevIdx = findFuzzy(['APIPREVCLOSE', 'APIPREVIOUSCLOSE', 'PIPREVCLOSE']);
    const apiHighIdx = findFuzzy(['APIHIGH', 'PIHIGH', 'API52WHIGH', 'PI52WHIGH']);
    const apiLowIdx = findFuzzy(['APILOW', 'PILOW', 'API52WLOW', 'PI52WLOW']);

    values.slice(1).forEach(r => {
      const rawCode = idxCode != null ? r[idxCode] : '';
      if (!rawCode) return;
      const code = String(rawCode).trim().toUpperCase();
      if (!code || (singleCode && code !== singleCode)) return;

      /** 
       * Robust Numeric Parser
       * Handles currency symbols, formulas, and spreadsheet errors (#VALUE!)
       */
      function num(idx) {
        if (idx == null) return null;
        let v = r[idx];
        if (v === '' || v == null) return null;
        if (typeof v === 'string' && v.startsWith('#')) return null; // Handle #VALUE!, #N/A, etc.
        if (typeof v === 'string') v = v.replace(/[^0-9.-]/g, '');
        const n = parseFloat(v);
        return isFinite(n) ? n : null;
      }

      let live = num(idxLive);
      if ((live === 0 || live == null) && apiPriceIdx != null) {
        const fb = parseFloat(r[apiPriceIdx]); if (fb > 0) live = fb;
      }

      let prevClose = num(idxPrev);
      if ((prevClose === 0 || prevClose == null) && apiPrevIdx != null) {
        const fb = parseFloat(r[apiPrevIdx]); if (fb > 0) prevClose = fb;
      }

      let high52 = num(idxHigh52);
      if ((high52 === 0 || high52 == null) && apiHighIdx != null) {
        const fb = parseFloat(r[apiHighIdx]); if (fb > 0) high52 = fb;
      }

      let low52 = num(idxLow52);
      if ((low52 === 0 || low52 == null) && apiLowIdx != null) {
        const fb = parseFloat(r[apiLowIdx]); if (fb > 0) low52 = fb;
      }

      // Final Cleanup & Sanity
      if (live > 0) {
        if (!high52) high52 = live; if (!low52) low52 = live;
        if (live > high52) high52 = live; if (live < low52) low52 = live;
      }

      const obj = {
        ASXCode: code,
        CompanyName: idxCompany != null ? (r[idxCompany] || null) : null,
        LivePrice: live,
        PrevClose: prevClose,
        High52: high52,
        Low52: low52
      };

      if (!compact) {
        if (idxMktCap != null) obj.MarketCap = num(idxMktCap);
        if (idxPE != null) obj.PE = num(idxPE);
      }

      // Metadata (Preserve separate keys)
      if (idxSector != null && r[idxSector]) obj.Sector = String(r[idxSector]).trim();
      if (idxIndustry != null && r[idxIndustry]) obj.Industry = String(r[idxIndustry]).trim();

      targetArray.push(obj);
    });
  };

  // Primary Data
  processSheet(PRICE_SHEET_NAME, prices);
  // Dashboard Specific Data
  processSheet(DASHBOARD_SHEET_NAME, dashboard);

  return { prices, dashboard };
}
